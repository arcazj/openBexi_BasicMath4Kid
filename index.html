
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenBexi Math Playground â€“ 3-D Operations</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">

    <script type="importmap">
        {
          "imports": {
            "three":         "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>

    <style>
        :root {
            --pink: #ff7aaa;
            --blue: #7ac4ff;
            --green: #7affc0;
            --yellow: #ffe67a;
            --navy: #0e1e35;
            --light: #ffffff;
            --shadow: 0 4px 10px rgba(0, 0, 0, .25);
            --btn-w: 4.2rem;
        }

        html {
            /* More robust responsive font scaling. Prevents UI from getting too big or small. */
            font-size: clamp(12px, 1.5vw, 16px);
        }

        * {
            box-sizing: border-box;
            font-family: 'Comic Sans MS', system-ui, sans-serif;
        }

        body {
            margin: 0;
            background: var(--navy);
            color: var(--light);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            /* Handles notches and system UI on mobile devices */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        header {
            padding: .6rem 1rem;
            font-size: 1.6rem;
            text-align: center;
            flex-shrink: 0;
        }

        #app {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        #controls {
            width: 24rem;
            min-width: 280px;
            max-width: 400px;
            background: var(--pink);
            padding: 1rem;
            border-radius: 0 .9rem .9rem 0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: var(--shadow);
            max-height: 100%;
            overflow-y: auto;
            z-index: 10;
        }

        @media (max-width: 640px) {
            #app {
                flex-direction: column;
            }

            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                width: 100%;
                border-radius: 0;
                max-height: none;
                overflow-y: visible;
                flex-shrink: 0;
                min-width: 0;
                max-width: none;
            }
        }

        .lang-row { display: flex; gap: .6rem; }
        .lang-btn { flex: 1; padding: .45rem; border: none; border-radius: .55rem; font-weight: bold; cursor: pointer; background: var(--green); color: var(--navy); box-shadow: var(--shadow); font-size: .9rem; }
        .lang-btn.active { filter: brightness(1.2); }
        .op-btn { width: 100%; padding: 1.1rem; border: none; border-radius: .75rem; font-size: 1.35rem; font-weight: bold; background: var(--blue); color: var(--navy); cursor: pointer; box-shadow: var(--shadow); }
        .op-btn.active { filter: brightness(1.15); }
        #equation { background: #000; padding: .4rem; border-radius: .5rem; font-size: 2rem; font-weight: bold; text-align: center; text-shadow: var(--shadow); }
        #answerPrompt { font-size: .97rem; text-align: center; margin-top: .25rem; }
        #keypad { display: grid; grid-template-columns:repeat(4, var(--btn-w)); gap: .6rem; justify-content: center; margin-top: .2rem; }
        .key-btn { width: var(--btn-w); height: var(--btn-w); line-height: var(--btn-w); border: none; border-radius: .65rem; font-size: 1.15rem; font-weight: bold; background: var(--yellow); color: var(--navy); cursor: pointer; box-shadow: var(--shadow); }
        .key-btn.correct { background: #10984d; color: #fff; }
        .key-btn.wrong { background: #d60709; color: #fff; }
        .key-btn:disabled { opacity: .75; cursor: not-allowed; }
        .key-btn.spacer { visibility: hidden; pointer-events: none; }

        #sceneContainer {
            flex: 1;
            position: absolute; /* Take up full space of parent */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            min-height: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            /* Prevents browser from hijacking touch events for scrolling/zooming */
            touch-action: none;
        }
    </style>
</head>

<body>
<header>ðŸ§® OpenBexi Math Playground</header>
<div id="app">
    <div id="controls">
        <div class="lang-row">
            <button class="lang-btn active" data-lang="en">English</button>
            <button class="lang-btn" data-lang="fr">FranÃ§ais</button>
            <button class="lang-btn" data-lang="es">EspaÃ±ol</button>
        </div>
        <button class="op-btn" data-op="add">Addition</button>
        <button class="op-btn" data-op="sub">Subtraction</button>
        <button class="op-btn" data-op="mul">Multiplication</button>
        <button class="op-btn" data-op="div">Division</button>
        <div id="equation">Pick an operation!</div>
        <div id="answerPrompt">Provide answer: Tap a number (0â€“18).</div>
        <div id="keypad"></div>
    </div>
    <div id="sceneContainer"></div>
</div>

<script type="module">
    /* â”€â”€â”€ IMPORTS â”€â”€â”€ */
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {RoomEnvironment} from 'three/addons/environments/RoomEnvironment.js';

    /* â”€â”€â”€ LANGUAGE STRINGS â”€â”€â”€ */
    const TXT = {
        en: { add: 'Addition', sub: 'Subtraction', mul: 'Multiplication', div: 'Division', pick: 'Pick an operation!', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' },
        fr: { add: 'Addition', sub: 'Soustraction', mul: 'Multiplication', div: 'Division', pick: 'Choisissez une opÃ©ration !', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' },
        es: { add: 'Suma', sub: 'Resta', mul: 'MultiplicaciÃ³n', div: 'DivisiÃ³n', pick: 'Â¡Elige una operaciÃ³n !', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' }
    };
    let LANG = 'en';

    /* â”€â”€â”€ DOM REFS â”€â”€â”€ */
    const eqn = document.getElementById('equation');
    const opBtns = [...document.querySelectorAll('.op-btn')];
    const langBtns = [...document.querySelectorAll('.lang-btn')];
    const keypad = document.getElementById('keypad');
    const controlsPane = document.getElementById('controls');
    const sceneContainer = document.getElementById('sceneContainer');

    /* â”€â”€â”€ KEYPAD BUILD â”€â”€â”€ */
    for (let n = 0; n <= 18; n++) {
        const k = document.createElement('button');
        k.className = 'key-btn';
        k.textContent = n;
        k.disabled = true;
        k.onclick = () => submitAnswer(n, k);
        keypad.appendChild(k);
    }
    keypad.appendChild(Object.assign(document.createElement('button'), {className: 'key-btn spacer'}));

    /* â”€â”€â”€ STATE MANAGEMENT â”€â”€â”€ */
    let group = null, answerVal = null, ready = false, animationLoop = null;
    let subtractionCubes = [];
    let currentOperation = null;

    /* â”€â”€â”€ THREE.JS SCENE SETUP â”€â”€â”€ */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e1e35);
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
    camera.position.set(0, 0, 15);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    // Capping pixel ratio is a major performance boost on mobile
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
    sceneContainer.appendChild(renderer.domElement);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
    renderer.setScissorTest(true); // Enable scissor testing

    scene.environment = new THREE.PMREMGenerator(renderer).fromScene(new RoomEnvironment(), 0.04).texture;

    /* Lights & Controls */
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    camera.position.set(5.1, -8, 18);
    controls.minDistance = 5;
    controls.maxDistance = 25;

    /* â”€â”€â”€ RESIZE AND VIEWPORT LOGIC â”€â”€â”€ */
    // This function calculates the area of the screen not covered by the controls.
    function updateViewport() {
        const appBounds = sceneContainer.getBoundingClientRect();
        const controlsBounds = controlsPane.getBoundingClientRect();

        let viewX, viewY, viewWidth, viewHeight;

        // Check if we are in the mobile layout (controls on top)
        if (window.innerWidth <= 640) {
            viewX = appBounds.left;
            viewY = controlsBounds.bottom;
            viewWidth = appBounds.width;
            viewHeight = appBounds.bottom - controlsBounds.bottom;
        } else { // Desktop layout (controls on the left)
            viewX = controlsBounds.right;
            viewY = appBounds.top;
            viewWidth = appBounds.right - controlsBounds.right;
            viewHeight = appBounds.height;
        }

        // Tell the renderer to only render in this calculated rectangle
        renderer.setScissor(viewX, window.innerHeight - viewY - viewHeight, viewWidth, viewHeight);
        renderer.setViewport(viewX, window.innerHeight - viewY - viewHeight, viewWidth, viewHeight);

        // Update camera aspect ratio to match the new viewport
        camera.aspect = viewWidth / viewHeight;
        camera.updateProjectionMatrix();
    }

    // Use ResizeObserver for reliable updates
    new ResizeObserver(updateViewport).observe(sceneContainer);
    new ResizeObserver(updateViewport).observe(controlsPane);
    updateViewport();


    /* â”€â”€â”€ HELPERS â”€â”€â”€ */
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

    function createCube(color) {
        return new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 1.2, 0.5),
            new THREE.MeshStandardMaterial({ // Standard material is faster
                color: color, metalness: 0.8, roughness: 0.2,
                transparent: true
            })
        );
    }

    function createRow(group, count, yPos, color) {
        const spacing = 0.7;
        const totalWidth = count * spacing;
        for (let i = 0; i < count; i++) {
            const cube = createCube(color);
            cube.position.set(-totalWidth / 2 + i * spacing + spacing / 2, yPos, 0);
            group.add(cube);
        }
    }

    const clearScene = () => {
        animationLoop = null;
        subtractionCubes = [];
        if (group) {
            scene.remove(group);
            group.traverse(child => {
                if (child.isMesh) {
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
        }
        group = new THREE.Group();
        scene.add(group);
    };

    /* â”€â”€â”€ UI ACTIONS â”€â”€â”€ */
    opBtns.forEach(b => b.onclick = () => {
        opBtns.forEach(btn => btn.classList.toggle('active', btn === b));
        keypad.querySelectorAll('.key-btn').forEach(k => {
            k.disabled = true; k.classList.remove('correct', 'wrong');
        });
        ready = false;
        currentOperation = b.dataset.op;
        eqn.textContent = TXT[LANG][currentOperation] + 'â€¦';

        if (currentOperation === 'add') demoAdd();
        else if (currentOperation === 'sub') demoSub();
        else if (currentOperation === 'mul') demoMul();
        else if (currentOperation === 'div') demoDiv();
    });

    function submitAnswer(val, btn) {
        if (!ready) return;
        ready = false;
        keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = true);
        const isCorrect = val === answerVal;
        btn.classList.add(isCorrect ? 'correct' : 'wrong');
        eqn.textContent = eqn.textContent.replace('?', answerVal) + ' ' + TXT[LANG][isCorrect ? 'correct' : 'wrong'];

        if (currentOperation === 'sub' && subtractionCubes.length > 0) {
            animationLoop = null;
            subtractionCubes.forEach(c => c.material.opacity = 1);
            let t = 0;
            const fadeOutLoop = () => {
                if (t < 1) {
                    t = Math.min(1, t + 0.05);
                    subtractionCubes.forEach(c => { c.material.opacity = 1 - t; c.position.y -= 0.1; });
                    requestAnimationFrame(fadeOutLoop);
                } else {
                    subtractionCubes.forEach(c => group.remove(c)); subtractionCubes = [];
                }
            };
            fadeOutLoop();
        } else if (currentOperation === 'div' && isCorrect) {
            const cubesToRemove = group.children.slice(answerVal);
            let t = 0;
            const fadeOutLoop = () => {
                if (t < 1) {
                    t = Math.min(1, t + 0.05);
                    cubesToRemove.forEach(c => { c.material.opacity = 1 - t; });
                    requestAnimationFrame(fadeOutLoop);
                } else {
                    cubesToRemove.forEach(c => group.remove(c));
                }
            };
            fadeOutLoop();
        }
    }

    /* â”€â”€â”€ MATH DEMOS â”€â”€â”€ */
    function demoAdd() {
        let a, b;
        do { a = rand(1, 9); b = rand(1, 9); } while (a + b > 18);
        clearScene();
        createRow(group, a, 2, 0x7ac4ff);
        const cubesA = group.children.slice(0, a);
        createRow(group, b, -2, 0xff7aaa);
        const cubesB = group.children.slice(a);

        eqn.textContent = `${a} + ${b} = ?`;
        answerVal = a + b;
        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.025);
                const easedT = 1 - Math.pow(1 - t, 3);
                cubesA.forEach(c => { c.position.y = THREE.MathUtils.lerp(2, 0.7, easedT); });
                cubesB.forEach(c => { c.position.y = THREE.MathUtils.lerp(-2, -0.7, easedT); });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    function demoSub() {
        const a = rand(1, 9), b = rand(1, a);
        clearScene();
        createRow(group, a, 0, 0x7affc0);
        eqn.textContent = `${a} âˆ’ ${b} = ?`;
        answerVal = a - b;
        subtractionCubes = group.children.slice(-b);
        animationLoop = () => {
            const blink = 0.4 + 0.6 * Math.abs(Math.sin(Date.now() * 0.005));
            subtractionCubes.forEach(c => { c.material.opacity = blink; });
        };
        ready = true;
        keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
    }

    function demoMul() {
        let a, b;
        do { a = rand(1, 4); b = rand(1, 4); } while (a * b > 18);
        clearScene();
        const spacingY = 1.4;
        const spacingX = 0.7;
        for (let i = 0; i < a; i++) {
            for (let j = 0; j < b; j++) {
                const cube = createCube(0xffe67a);
                cube.position.set(
                    -((b - 1) * spacingX) / 2 + j * spacingX,
                    -((a - 1) * spacingY) / 2 + i * spacingY,
                    0
                );
                cube.scale.set(0, 0, 0);
                group.add(cube);
            }
        }
        eqn.textContent = `${a} Ã— ${b} = ?`;
        answerVal = a * b;
        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.03);
                group.children.forEach((c, i) => {
                    const delay = (i * 0.02);
                    const localT = Math.max(0, Math.min(1, (t - delay) / (1-delay)));
                    c.scale.set(localT, localT, localT);
                });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    function demoDiv() {
        let parts, each, total;
        do { parts = rand(2, 4); each = rand(2, 4); total = parts * each; } while (total > 18);
        clearScene();
        createRow(group, total, 0, 0x7ac4ff);
        eqn.textContent = `${total} Ã· ${parts} = ?`;
        answerVal = each;
        const spacing = 0.7;
        const groupWidth = each * spacing;
        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.02);
                const easedT = 1 - Math.pow(1 - t, 3);
                group.children.forEach((c, i) => {
                    const gIndex = Math.floor(i / each);
                    const pInGroup = i % each;
                    const startX = c.position.x;
                    const endX = (gIndex - (parts - 1) / 2) * (groupWidth + 1.2) + (pInGroup - (each-1)/2) * spacing;
                    c.position.x = THREE.MathUtils.lerp(startX, endX, easedT);
                });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    /* â”€â”€â”€ RENDER LOOP â”€â”€â”€ */
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (animationLoop) {
            animationLoop();
        }
        // The renderer uses the viewport and scissor settings defined in onResize
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
