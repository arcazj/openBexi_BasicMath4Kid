<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenBexi Math Playground â€“ 3-D Operations</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">

    <script type="importmap">
        {
          "imports": {
            "three":         "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>

    <style>
        :root {
            --pink: #ff7aaa;
            --blue: #7ac4ff;
            --green: #7affc0;
            --yellow: #ffe67a;
            --navy: #0e1e35;
            --light: #ffffff;
            --shadow: 0 4px 10px rgba(0, 0, 0, .25);
            --btn-w: 4.2rem;
        }

        html {
            /* Make the root font size responsive to viewport size. All 'rem' units will now scale. */
            font-size: calc(1vmin + 0.5rem); /* vmin is the smaller of vw or vh, ensuring balanced scaling */
        }

        * {
            box-sizing: border-box;
            font-family: 'Comic Sans MS', system-ui, sans-serif;
        }

        body {
            margin: 0;
            background: var(--navy);
            color: var(--light);
            display: flex;
            flex-direction: column;
            height: 100vh;
            /* Prevents pull-to-refresh and other gestures over the canvas */
            overflow: hidden;
        }

        header {
            padding: .6rem 1rem;
            font-size: 1.6rem;
            text-align: center;
            flex-shrink: 0; /* Prevents header from shrinking */
        }

        #app {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative; /* For stacking context */
        }

        #controls {
            /* Make width responsive using rem, with min/max caps in px to prevent extremes */
            width: 24rem;
            min-width: 280px; /* A hard min-width is good for usability on small screens */
            max-width: 400px; /* A hard max-width is good for large screens */
            background: var(--pink);
            padding: 1rem;
            border-radius: 0 .9rem .9rem 0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: var(--shadow);
            max-height: 100vh;
            overflow-y: auto; /* Allow scrolling if content overflows */
            z-index: 10;
        }

        @media (max-width: 640px) {
            #app {
                flex-direction: column;
            }

            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                width: 100%;
                border-radius: 0;
                max-height: none; /* Allow controls to take needed height */
                overflow-y: visible;
                flex-shrink: 0; /* Prevent controls from shrinking */
                /* Remove min/max width on mobile as it takes full width */
                min-width: 0;
                max-width: none;
            }
        }

        .lang-row {
            display: flex;
            gap: .6rem;
        }

        .lang-btn {
            flex: 1;
            padding: .45rem;
            border: none;
            border-radius: .55rem;
            font-weight: bold;
            cursor: pointer;
            background: var(--green);
            color: var(--navy);
            box-shadow: var(--shadow);
            font-size: .9rem;
        }

        .lang-btn.active {
            filter: brightness(1.2);
        }

        .op-btn {
            width: 100%;
            padding: 1.1rem;
            border: none;
            border-radius: .75rem;
            font-size: 1.35rem;
            font-weight: bold;
            background: var(--blue);
            color: var(--navy);
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        .op-btn.active {
            filter: brightness(1.15);
        }

        #equation {
            background: #000;
            padding: .4rem;
            border-radius: .5rem;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            text-shadow: var(--shadow);
        }

        #answerPrompt {
            font-size: .97rem;
            text-align: center;
            margin-top: .25rem;
        }

        #keypad {
            display: grid;
            grid-template-columns:repeat(4, var(--btn-w));
            gap: .6rem;
            justify-content: center;
            margin-top: .2rem;
        }

        .key-btn {
            width: var(--btn-w);
            height: var(--btn-w);
            line-height: var(--btn-w);
            border: none;
            border-radius: .65rem;
            font-size: 1.15rem;
            font-weight: bold;
            background: var(--yellow);
            color: var(--navy);
            cursor: pointer;
            box-shadow: var(--shadow);
        }

        .key-btn.correct {
            background: #10984d;
            color: #fff;
        }

        .key-btn.wrong {
            background: #d60709;
            color: #fff;
        }

        .key-btn:disabled {
            opacity: .75;
            cursor: not-allowed;
        }

        .key-btn.spacer {
            visibility: hidden;
            pointer-events: none;
        }

        #sceneContainer {
            flex: 1;
            position: relative;
            min-height: 0; /* Fix for flexbox sizing in some browsers */
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block
        }
    </style>
</head>

<body>
<header>ðŸ§® OpenBexi Math Playground</header>

<div id="app">
    <div id="controls">
        <div class="lang-row">
            <button class="lang-btn active" data-lang="en">English</button>
            <button class="lang-btn" data-lang="fr">FranÃ§ais</button>
            <button class="lang-btn" data-lang="es">EspaÃ±ol</button>
        </div>

        <button class="op-btn" data-op="add">Addition</button>
        <button class="op-btn" data-op="sub">Subtraction</button>
        <button class="op-btn" data-op="mul">Multiplication</button>
        <button class="op-btn" data-op="div">Division</button>

        <div id="equation">Pick an operation!</div>
        <div id="answerPrompt">Provide answer: Tap a number (0â€“18).</div>
        <div id="keypad"></div>
    </div>

    <div id="sceneContainer"></div>
</div>

<script type="module">
    /* â”€â”€â”€ IMPORTS â”€â”€â”€ */
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {RoomEnvironment} from 'three/addons/environments/RoomEnvironment.js';

    /* â”€â”€â”€ LANGUAGE STRINGS â”€â”€â”€ */
    const TXT = {
        en: { add: 'Addition', sub: 'Subtraction', mul: 'Multiplication', div: 'Division', pick: 'Pick an operation!', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' },
        fr: { add: 'Addition', sub: 'Soustraction', mul: 'Multiplication', div: 'Division', pick: 'Choisissez une opÃ©ration !', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' },
        es: { add: 'Suma', sub: 'Resta', mul: 'MultiplicaciÃ³n', div: 'DivisiÃ³n', pick: 'Â¡Elige una operaciÃ³n !', correct: 'ðŸ˜Š', wrong: 'ðŸ˜•' }
    };
    let LANG = 'en';

    /* â”€â”€â”€ DOM REFS â”€â”€â”€ */
    const eqn = document.getElementById('equation');
    const opBtns = [...document.querySelectorAll('.op-btn')];
    const langBtns = [...document.querySelectorAll('.lang-btn')];
    const keypad = document.getElementById('keypad');
    const controlsPane = document.getElementById('controls');
    const container = document.getElementById('sceneContainer');

    /* â”€â”€â”€ KEYPAD BUILD â”€â”€â”€ */
    for (let n = 0; n <= 18; n++) {
        const k = document.createElement('button');
        k.className = 'key-btn';
        k.textContent = n;
        k.disabled = true;
        k.onclick = () => submitAnswer(n, k);
        keypad.appendChild(k);
    }
    keypad.appendChild(Object.assign(document.createElement('button'), {className: 'key-btn spacer'}));

    /* â”€â”€â”€ STATE MANAGEMENT â”€â”€â”€ */
    let group = null, answerVal = null, ready = false, animationLoop = null;
    let subtractionCubes = []; // Holds cubes for the subtraction animation
    let currentOperation = null; // To track the current math operation

    /* â”€â”€â”€ THREE.JS SCENE SETUP â”€â”€â”€ */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e1e35);
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(6, 6, 10);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;

    scene.environment = new THREE.PMREMGenerator(renderer).fromScene(new RoomEnvironment(), 0.04).texture;

    /* Lights */
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    /* Controls */
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.minDistance = 5;
    controls.maxDistance = 20;

    /* â”€â”€â”€ RESPONSIVE POSITIONING LOGIC â”€â”€â”€ */
    const centerOffset = new THREE.Vector2();
    function updateCentering() {
        const canvasBounds = container.getBoundingClientRect();
        if (window.innerWidth > 640) {
            // Reduced the multiplier from 0.5 to 0.3 to move the group left, closer to the menu
            centerOffset.x = controlsPane.offsetWidth * 0.05;
            centerOffset.y = 0;
        } else {
            // Reduced the multiplier from 1.1 to 0.8 to move the group up, closer to the menu
            centerOffset.x = 0;
            centerOffset.y = -controlsPane.offsetHeight / 2 * 0.8;
        }
        const viewHeight = canvasBounds.height;
        const fov = THREE.MathUtils.degToRad(camera.fov);
        const worldHeight = 2 * Math.tan(fov) * camera.position.z;
        const pixelToWorldScale = worldHeight / viewHeight;
        if (group) {
            group.position.x = centerOffset.x * pixelToWorldScale;
            group.position.y = centerOffset.y * pixelToWorldScale;
        }
    }

    /* â”€â”€â”€ RESIZE HANDLER â”€â”€â”€ */
    function onResize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        updateCentering();
        camera.updateProjectionMatrix();
    }
    new ResizeObserver(onResize).observe(container);
    new ResizeObserver(onResize).observe(controlsPane);
    onResize();

    /* â”€â”€â”€ HELPERS â”€â”€â”€ */
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

    function createCube(color) {
        return new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 1, 0.4),
            new THREE.MeshPhysicalMaterial({
                color: color, metalness: 0.9, roughness: 0.1,
                envMapIntensity: 0.8, clearcoat: 0.2, clearcoatRoughness: 0.1,
                transparent: true // Needed for opacity changes
            })
        );
    }

    function createRow(group, count, yPos, color) {
        const totalWidth = count * 0.6;
        for (let i = 0; i < count; i++) {
            const cube = createCube(color);
            cube.position.set(-totalWidth / 2 + i * 0.6 + 0.3, yPos, 0);
            group.add(cube);
        }
    }

    const clearScene = () => {
        animationLoop = null;
        subtractionCubes = []; // Clear subtraction cubes
        if (group) {
            scene.remove(group);
            group.traverse(child => {
                if (child.isMesh) {
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
        }
        group = new THREE.Group();
        scene.add(group);
        updateCentering();
    };

    /* â”€â”€â”€ UI ACTIONS â”€â”€â”€ */
    langBtns.forEach(b => b.onclick = () => {
        LANG = b.dataset.lang;
        langBtns.forEach(l => l.classList.toggle('active', l === b));
        opBtns.forEach(o => o.textContent = TXT[LANG][o.dataset.op]);
        if (!ready) eqn.textContent = TXT[LANG].pick;
    });

    opBtns.forEach(b => b.onclick = () => {
        opBtns.forEach(btn => btn.classList.toggle('active', btn === b));
        keypad.querySelectorAll('.key-btn').forEach(k => {
            k.disabled = true;
            k.classList.remove('correct', 'wrong');
        });
        ready = false;
        currentOperation = b.dataset.op; // Keep track of the current operation
        eqn.textContent = TXT[LANG][currentOperation] + 'â€¦';

        if (currentOperation === 'add') demoAdd();
        else if (currentOperation === 'sub') demoSub();
        else if (currentOperation === 'mul') demoMul();
        else if (currentOperation === 'div') demoDiv();
    });

    function submitAnswer(val, btn) {
        if (!ready) return;
        ready = false;
        keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = true);
        const isCorrect = val === answerVal;
        btn.classList.add(isCorrect ? 'correct' : 'wrong');
        eqn.textContent = eqn.textContent.replace('?', answerVal) + ' ' + TXT[LANG][isCorrect ? 'correct' : 'wrong'];

        // Handle post-answer animations based on the operation
        if (currentOperation === 'sub' && subtractionCubes.length > 0) {
            animationLoop = null; // Stop the blinking
            subtractionCubes.forEach(c => c.material.opacity = 1);

            let t = 0;
            const fadeOutLoop = () => {
                if (t < 1) {
                    t = Math.min(1, t + 0.05);
                    const easedT = 1 - Math.pow(1 - t, 3);
                    subtractionCubes.forEach(cube => {
                        cube.material.opacity = 1 - easedT;
                        cube.position.y = -easedT * 2;
                    });
                    requestAnimationFrame(fadeOutLoop);
                } else {
                    subtractionCubes.forEach(cube => group.remove(cube));
                    subtractionCubes = []; // Clear the array
                }
            };
            fadeOutLoop();
        } else if (currentOperation === 'div' && isCorrect) {
            // Keep the first group (size of 'answerVal'), remove the rest.
            const cubesToRemove = group.children.slice(answerVal);

            let t = 0;
            const fadeOutLoop = () => {
                if (t < 1) {
                    t = Math.min(1, t + 0.05);
                    const easedT = t * t; // Ease in quad for a quick fade
                    cubesToRemove.forEach(cube => {
                        cube.material.opacity = 1 - easedT;
                    });
                    requestAnimationFrame(fadeOutLoop);
                } else {
                    cubesToRemove.forEach(cube => group.remove(cube));
                }
            };
            fadeOutLoop();
        }
    }

    /* â”€â”€â”€ MATH DEMOS â”€â”€â”€ */
    function demoAdd() {
        let a, b;
        do { a = rand(1, 9); b = rand(1, 9); } while (a + b > 18);

        clearScene();
        createRow(group, a, 1.5, 0x7ac4ff);
        const cubesA = group.children.slice(0, a);
        createRow(group, b, -1.5, 0xff7aaa);
        const cubesB = group.children.slice(a);

        eqn.textContent = `${a} + ${b} = ?`;
        answerVal = a + b;

        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.025);
                const easedT = 1 - Math.pow(1 - t, 3);
                cubesA.forEach(cube => {
                    cube.position.y = THREE.MathUtils.lerp(1.5, 0.6, easedT);
                });
                cubesB.forEach(cube => {
                    cube.position.y = THREE.MathUtils.lerp(-1.5, -0.6, easedT);
                });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    function demoSub() {
        const a = rand(1, 9), b = rand(1, a);
        clearScene();
        createRow(group, a, 0, 0x7affc0);

        eqn.textContent = `${a} âˆ’ ${b} = ?`;
        answerVal = a - b;

        subtractionCubes = group.children.slice(-b);

        animationLoop = () => {
            const blink = 0.4 + 0.6 * Math.abs(Math.sin(Date.now() * 0.005));
            subtractionCubes.forEach(cube => {
                cube.material.opacity = blink;
            });
        };

        ready = true;
        keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
    }

    function demoMul() {
        let a, b;
        do { a = rand(1, 4); b = rand(1, 4); } while (a * b > 18);
        clearScene();
        const gridWidth = b * 0.6;
        const gridHeight = a * 1.2;
        for (let i = 0; i < a; i++) {
            for (let j = 0; j < b; j++) {
                const cube = createCube(0xffe67a);
                cube.position.set(
                    -gridWidth / 2 + j * 0.6 + 0.3,
                    -gridHeight / 2 + i * 1.2 + 0.6,
                    0
                );
                cube.scale.set(0, 0, 0);
                group.add(cube);
            }
        }
        eqn.textContent = `${a} Ã— ${b} = ?`;
        answerVal = a * b;
        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.03);
                const easedT = 1 - Math.pow(1 - t, 4);
                group.children.forEach((cube, i) => {
                    const delay = (i * 0.02);
                    const localT = Math.max(0, Math.min(1, (t - delay) / (1 - delay)));
                    cube.scale.set(localT, localT, localT);
                });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    function demoDiv() {
        let parts, each, total;
        do { parts = rand(2, 4); each = rand(2, 4); total = parts * each; } while (total > 18);
        clearScene();
        createRow(group, total, 0, 0x7ac4ff);
        eqn.textContent = `${total} Ã· ${parts} = ?`;
        answerVal = each;
        const groupWidth = each * 0.6;
        let t = 0;
        animationLoop = () => {
            if (t < 1) {
                t = Math.min(1, t + 0.02);
                const easedT = 1 - Math.pow(1 - t, 3);
                group.children.forEach((cube, i) => {
                    const groupIndex = Math.floor(i / each);
                    const posInGroup = i % each;
                    const startX = cube.position.x;
                    const endX = (groupIndex - (parts - 1) / 2) * (groupWidth + 0.5) + (posInGroup - (each - 1) / 2) * 0.6;
                    cube.position.x = THREE.MathUtils.lerp(startX, endX, easedT);
                });
            } else {
                ready = true;
                keypad.querySelectorAll('.key-btn').forEach(k => k.disabled = false);
                animationLoop = null;
            }
        };
    }

    /* â”€â”€â”€ RENDER LOOP â”€â”€â”€ */
    function animate() {
        requestAnimationFrame(animate);
        controls.update(); // For damping
        if (animationLoop) {
            animationLoop();
        }
        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>